from time import time
import pymesh
import timeit
import os 
import matplotlib.pyplot as plt

# using a grid of mesh
# Generate a grid of mesh and the cube beneath
number = 5 # Don't change this number, because the cube we load from the directory is generated is 21 * 22 * 21
distance = 4 
list_of_grain_dict = []
scale = 1
os.chdir("/Users/shirzart/Desktop/iBrus-fuzzy-front-end/libraries_explorations")
grain_raw_mesh = pymesh.load_mesh("grains/Cuboctahedron.stl")

#Here we generate the grid of grains, which has to be 5*5, because 
for element in range(number):
    for iterator in range(number ** 2):
        reminder = iterator % number
        if reminder == 0:
            position = iterator // number
        else:
            position = reminder 

        new_grain =  pymesh.form_mesh(grain_raw_mesh.vertices + [element * distance + scale, position * distance + scale, number * distance + scale], grain_raw_mesh.faces)
        new_grain_dict = {"mesh": new_grain}
        list_of_grain_dict.append(new_grain_dict)
        


# Here we still use the CSG.Tree for doing the union of grain grid, because it's faster. See README.MD in detail.
CSG_grid_generation = pymesh.CSGTree({'union': list_of_grain_dict}) 


# Load cube mesh that is generated by different order of remashing 

order1_cube = pymesh.load_mesh("pymesh_cube_1_numbers_.stl")
order2_cube = pymesh.load_mesh("pymesh_cube_2_numbers_.stl")
order3_cube = pymesh.load_mesh("pymesh_cube_3_numbers_.stl")
order4_cube = pymesh.load_mesh("pymesh_cube_4_numbers_.stl")
order5_cube = pymesh.load_mesh("pymesh_cube_5_numbers_.stl")
order6_cube = pymesh.load_mesh("pymesh_cube_6_numbers_.stl")
order7_cube = pymesh.load_mesh("pymesh_cube_7_numbers_.stl")
order8_cube = pymesh.load_mesh("pymesh_cube_8_numbers_.stl") 
order9_cube = pymesh.load_mesh("pymesh_cube_9_numbers_.stl")

# load_start_time = timeit.default_timer()
# print("Loading the pre-generated cube_block mesh in progress ...\.")
# order10_cube = pymesh.load_mesh("pymesh_cube_10_numbers_.stl")
# load_end_time = timeit.default_timer()
# print(f"It took {load_end_time - load_start_time} time to load it.")

# Select the different cube you are interested in. The order9 and order10 is not here, because it takes too much time to load and calculate it.
cube_list = [order1_cube, order2_cube, order3_cube, order4_cube, order5_cube, order6_cube, order7_cube, order8_cube]


runtime_collection = []
for element in cube_list:
    cube_block_dict = {"mesh": element}
    difference_start_time = timeit.default_timer()
    CSG_entire_tree = pymesh.CSGTree({'difference': [cube_block_dict, CSG_grid_generation]})
    difference_end_time = timeit.default_timer()
    runtime_collection.append(difference_end_time - difference_start_time)
    print(runtime_collection)


# Plot and save the runtime result

order_number = list(range(1,len(cube_list)+1))
plt.figure()
plt.plot(order_number, runtime_collection,'bs')
plt.xlabel("number of orders of submesh from the original box")
plt.ylabel("run time in seconds")
plt.title("Pymesh Run time profiling for different order of submesh")
plt.show()
plt.savefig("pymesh_runtime_submesh_scaling.png")